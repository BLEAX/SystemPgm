return 0 : 성공(success)을 반환
0을 제외한 모든 숫자는 에러


**option** : 
ls의 옵션 : long option과 short option으로 나눌 수 있음. (하는 동작은 같음.) 
    -a 또는 --all : (all, 모두 출력) 
    등등 대부분의 옵션은 long option과 short option 둘 다 가지고 있음.
    예외) -l : (list, 리스트 출력)은 long option이 없음.


ls 구현 시 all을 주고 싶을 시 : 
  -a의 경우에는 히든 파일까지 출력
  -l의 경우에는 long으로 출력


ls -l / 이나 ls / -l 은 순서는 다르지만 모두 같은 동작을 함.


명령 구현시 : short option과 long option을 구현하면 점수가 높아짐.
1. ls구현 시 1점
2. -l구현 시 1점
3. /구현 시 1점
4. --all 구현 시 1점 등등


30개 구현 시 만점.
ls로만 여러 개 만들 수 있고,
교재에 있는 명령어만 전부 구현해도 20개


구두 질문 대답 못하면 점수 인정 X


파일 또는 레코드에 잠금이 필요한 이유 : 
- 트랜지션 관리하기 위해서 (ACID 특성 구현)


레코드를 읽기 전에 그 레코드에 대해 읽기 잠금을 한다.


***권고 잠금과 강제 잠금*** : 
**권고 잠금** : 
- 잠금을 할 수 있지만 강제되지는 않음
- 이미 잠금된 파일의 영역에 대해서도 잠금 규칙을 무시하고 읽거나 쓰는 것이 가능
- 모든 관련 프로세스들이 자발적으로 잠금 규칙을 준수해야 한다.


**강제 잠금** : 
- 이미 잠금된 파일에 대해 잠금 규칙을 무시하고 읽거나 쓰는 것이 불가능
- 커널이 잠금 규칙을 강제하므로 시스템의 부하가 증가
- 강제 잠금을 잘 안하는 경우가 대부분


**man 번호**
섹션 1. 명령어에 대한 설명
섹션 2. 시스템 호출
섹션 3. C 표준 라이브러리 함수들
... 9까지 있으며 9는 있을 수도 있고 없을 수도 있음.


**시스템 호출과 C 라이브러리 함수**
- C 라이브러리 함수는 보통 시스템 호출을 포장해 놓은 함수


C언어의 파일 입출력 과정 :
1. 파일 열기
2. 파일 입출력
3. 파일 닫기


File 구조체 : 
파일 관련 시스템 호출 : 파일 디스크립터


표준 I/O 스트림 : 
프로그램이 시작되면 자동으로 open되는 스트림
표준 입출력 포인터 1. stdin, 2. stdout, 3. stderr


파일 디스크립터가 4번부터인 이유 : 1, 2, 3번은 이미 부여되어 있기 때문에


**ASCII코드로 저장된 텍스트 파일과 바이너리 파일의 차이점** : 
- 텍스트 파일은 r옵션으로 처리. (개행을 (CRLF, 13,10) 으로 처리)
- 바이너리 파일은 rb옵션으로 처리. 


- 텍스트 파일은 문자를 사람이 읽을 수 있는 형식으로 저장
- 바이너리 파일은 문자를 사람이 읽을 수 없는 형식으로 저장



scanf("%c")의 문제점 : 
키보드 입력은 모두 입력 버퍼에 담긴다. scanf는 입력버퍼에서 명령 받은 대로 받아오는데,
무언가를 입력한 직후 엔터키를 사용하면 버퍼에 개행이 이미 들어가 있기 때문에 개행을 받아와버린다. 
(int나 다른 자료형에는 문제가 발생하지 않음.)
-> 대신 입력과 동시에 버퍼에 있는 것을 사용해버리는 getchar()쓰자.


C 라이브러리 버퍼 :
C 라이브러리 버퍼의 사용 목적 : 디스크 I/O 수행의 최소화
I/O가 자주 일어나면 시스템 부하가 일어나기 때문에 여러가지 방식으로 버퍼를 사용한다.


**버퍼(buffer)** : 
속도를 향상시키기 위해, 한 번에 처리하기 위해 데이터를 모아둔 임시 저장공간



**Shell의 실행 절차** : 
1. 시작 파일 읽고 실행
2. 프롬프트를 출력하고 사용자 명령 기다림
3. 사용자 명령 실행
4. 다시 프롬프트를 출력하고 사용자 명령 기다려 사용자 명령 실행 반복하거나
   Ctrl + D를 눌러 종료



이번 주 발표 주제
booting 과정(init, systemd) - 리눅스
format(raw format, low format)



파일을 지우면 디스크에 정보가 남아있음.
-> 포멧을 해도 정보는 남아있다. 
(파일의 제일 첫 번째 글자만 바꿔버림. 검색, 실행 못하도록)
-> 프로그램을 통해 복구 가능
-> 완전히 삭제하고 싶을 시?
-> low format



**프로세스** : 
- 실행중인 프로그램을 프로세스라고 부른다.
- 보조기억장치에서 주기억장치로 적재되면 프로세스가 됨.
- 각 프로세스는 유일한 프로세스 번호 PID를 갖는다.
- ps 명령어를 사용하여 나의 프로세스들을 볼 수 있다.



전면 처리와 후면 처리 : 
- 전면 처리 : **명령어를 입력하면 명령어가 전면에서 실행되며** 명령어 실행이 끝날 때까지 쉘이 기다려준다.
- (sleep 10; echo done) 10초 sleep하고 끝나면 done을 출력


- 후면 처리 : **명령어들을 후면에서 처리하고** 전면에서는 다른 작업을 할 수 있으면 동시에 여러 작업을 수행할 수 있다. (끝에 &사용)
- (sleep 10; echo done)& 10초 sleep하고 끝나면 done을 출력하지만 그 와중에도 다른 작업 수행가능


wait [프로세스번호] : 
해당 프로세스 번호를 갖는 자식 프로세스가 종료될 때까지 기다린다.
프로세스 번호를 지정하지 않으면 모든 자식 프로세스를 기다린다.


프로세스는 끝이나면 exit를 호출한다.
exit는 프로세스를 종료하고 return은 돌아간다.


echo $PATH : 
실행파일의 경로를 출력한다.


printenv.c 함수도 구현해야 하는 명령어 중 하나
(환경변수를 출력하는 c프로그램, echo $PATH와 같은 동작)


```
#include <stdio.h>
#include <stdlib.h>
/* 환경 변수를 3개 프린트한다. */
int main(int argc, char *argv[]) {
    char *ptr;
    ptr = getenv("HOME");
    printf("HOME = %s \n", ptr);
    ptr = getenv("SHELL");
    printf("SHELL = %s \n", ptr);
    ptr = getenv("PATH");
    printf("PATH = %s \n", ptr);
    exit(0);
}
```


**exit()** : 
- 모든 열려진 스트림을 닫고 뒷정리(출력 버퍼에 있는 내용을 디스크에 쓰는 등의 행동) 후, 프로세스를 정상적으로 종료.
- 종료 코드를 부모 프로세스에게 전달한다.
**(_exit()는 뒷처리 안하는 종료)**


**atexit()** :
- 이 함수를 통해 exit(종료)시의 행동을 핸들링할 수 있다.


```
int getpid( ); //프로세스의 ID를 리턴한다.
int getppid( ); //부모 프로세스의 ID를 리턴한다.
```


![image](https://github.com/BLEAX/SystemPgm/assets/109516312/80564f04-0873-4cf9-9003-8f898db4beef)
C 프로그램 시작 및 종료의 과정 외우기
